"use strict";(self.webpackChunkflowtorch=self.webpackChunkflowtorch||[]).push([[2019],{6249:function(o,n,t){t.r(n),t.d(n,{contentTitle:function(){return d},default:function(){return _},frontMatter:function(){return m},metadata:function(){return f},toc:function(){return h}});var i=t(7462),e=t(3366),a=(t(7294),t(3905)),r=t(2814),s=t(1436),l=(t(1032),t(8666)),c=(t(2520),t(84),t(7868)),p=["components"],m={id:"flowtorch.ops.monotonic_rational_spline",sidebar_label:"monotonic_rational_spline"},d=void 0,f={unversionedId:"api/flowtorch.ops.monotonic_rational_spline",id:"api/flowtorch.ops.monotonic_rational_spline",isDocsHomePage:!1,title:"flowtorch.ops.monotonic_rational_spline",description:"flowtorch  ops  monotonic_rational_spline",source:"@site/docs/api/flowtorch.ops.monotonic_rational_spline.mdx",sourceDirName:"api",slug:"/api/flowtorch.ops.monotonic_rational_spline",permalink:"/api/flowtorch.ops.monotonic_rational_spline",editUrl:"https://github.com/facebookincubator/flowtorch/edit/main/website/docs/api/flowtorch.ops.monotonic_rational_spline.mdx",tags:[],version:"current",frontMatter:{id:"flowtorch.ops.monotonic_rational_spline",sidebar_label:"monotonic_rational_spline"},sidebar:"apiSidebar",previous:{title:"clipped_sigmoid",permalink:"/api/flowtorch.ops.clipped_sigmoid"},next:{title:"softplus_inv",permalink:"/api/flowtorch.ops.softplus_inv"}},h=[{value:'<span className="doc-symbol-name">flowtorch.ops.monotonic_rational_spline</span>',id:"function",children:[],level:2}],u={toc:h};function _(o){var n=o.components,t=(0,e.Z)(o,p);return(0,a.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(c.Z,{url:"https://github.com/facebookincubator/flowtorch/blob/main/flowtorch/ops/__init__.py",mdxType:"PythonNavbar"},(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/api/flowtorch"},"flowtorch")," ",(0,a.kt)(r.G,{icon:s.cLY,size:"sm",mdxType:"FontAwesomeIcon"})," ",(0,a.kt)("a",{parentName:"p",href:"/api/flowtorch.ops"},"ops")," ",(0,a.kt)(r.G,{icon:s.cLY,size:"sm",mdxType:"FontAwesomeIcon"})," ",(0,a.kt)("em",{parentName:"p"},"monotonic_rational_spline"))),(0,a.kt)(l.Z,{mdxType:"PythonFunction"},(0,a.kt)("div",{className:"doc-function-row"},(0,a.kt)("div",{className:"doc-function-label"},(0,a.kt)("span",{className:"doc-symbol-label"},"function")),(0,a.kt)("div",{className:"doc-function-signature"},(0,a.kt)("h2",{id:"function"},(0,a.kt)("span",{className:"doc-symbol-name"},"flowtorch.ops.monotonic","_","rational","_","spline")),(0,a.kt)("span",{className:"doc-symbol-signature"},"(inputs: torch.Tensor, widths: torch.Tensor, heights: torch.Tensor, derivatives: torch.Tensor, lambdas: Union[torch.Tensor, NoneType] = None, inverse: bool = False, bound: float = 3.0, min_bin_width: float = 0.001, min_bin_height: float = 0.001, min_derivative: float = 0.001, min_lambda: float = 0.025, eps: float = 1e-06) -> Tuple[torch.Tensor, torch.Tensor]")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'\nCalculating a monotonic rational spline (linear or quadratic) or its inverse,\nplus the log(abs(detJ)) required for normalizing flows.\nNOTE: I omit the docstring with parameter descriptions for this method since it\nis not considered "public" yet!\n\n')))}_.isMDXComponent=!0}}]);