"use strict";(self.webpackChunkflowtorch=self.webpackChunkflowtorch||[]).push([[2019],{6249:(o,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>p,default:()=>f,frontMatter:()=>c,metadata:()=>m,toc:()=>d});var i=n(7462),e=(n(7294),n(3905)),a=n(2814),s=n(1436),l=(n(1032),n(8666)),r=(n(2520),n(84),n(7868));const c={id:"flowtorch.ops.monotonic_rational_spline",sidebar_label:"monotonic_rational_spline"},p=void 0,m={unversionedId:"api/flowtorch.ops.monotonic_rational_spline",id:"api/flowtorch.ops.monotonic_rational_spline",isDocsHomePage:!1,title:"flowtorch.ops.monotonic_rational_spline",description:"flowtorch  ops  monotonic_rational_spline",source:"@site/docs/api/flowtorch.ops.monotonic_rational_spline.mdx",sourceDirName:"api",slug:"/api/flowtorch.ops.monotonic_rational_spline",permalink:"/api/flowtorch.ops.monotonic_rational_spline",editUrl:"https://github.com/facebookincubator/flowtorch/edit/main/website/docs/api/flowtorch.ops.monotonic_rational_spline.mdx",tags:[],version:"current",frontMatter:{id:"flowtorch.ops.monotonic_rational_spline",sidebar_label:"monotonic_rational_spline"},sidebar:"apiSidebar",previous:{title:"clipped_sigmoid",permalink:"/api/flowtorch.ops.clipped_sigmoid"},next:{title:"softplus_inv",permalink:"/api/flowtorch.ops.softplus_inv"}},d=[{value:'<span className="doc-symbol-name">flowtorch.ops.monotonic_rational_spline</span>',id:"function",children:[],level:2}],h={toc:d};function f(o){let{components:t,...n}=o;return(0,e.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,e.kt)(r.Z,{url:"https://github.com/facebookincubator/flowtorch/blob/main/flowtorch/ops/__init__.py",mdxType:"PythonNavbar"},(0,e.kt)("p",null,(0,e.kt)("a",{parentName:"p",href:"/api/flowtorch"},"flowtorch")," ",(0,e.kt)(a.G,{icon:s.cLY,size:"sm",mdxType:"FontAwesomeIcon"})," ",(0,e.kt)("a",{parentName:"p",href:"/api/flowtorch.ops"},"ops")," ",(0,e.kt)(a.G,{icon:s.cLY,size:"sm",mdxType:"FontAwesomeIcon"})," ",(0,e.kt)("em",{parentName:"p"},"monotonic_rational_spline"))),(0,e.kt)(l.Z,{mdxType:"PythonFunction"},(0,e.kt)("div",{className:"doc-function-row"},(0,e.kt)("div",{className:"doc-function-label"},(0,e.kt)("span",{className:"doc-symbol-label"},"function")),(0,e.kt)("div",{className:"doc-function-signature"},(0,e.kt)("h2",{id:"function"},(0,e.kt)("span",{className:"doc-symbol-name"},"flowtorch.ops.monotonic","_","rational","_","spline")),(0,e.kt)("span",{className:"doc-symbol-signature"},"(inputs: torch.Tensor, widths: torch.Tensor, heights: torch.Tensor, derivatives: torch.Tensor, lambdas: Union[torch.Tensor, NoneType] = None, inverse: bool = False, bound: float = 3.0, min_bin_width: float = 0.001, min_bin_height: float = 0.001, min_derivative: float = 0.001, min_lambda: float = 0.025, eps: float = 1e-06) -> Tuple[torch.Tensor, torch.Tensor]")))),(0,e.kt)("pre",null,(0,e.kt)("code",{parentName:"pre"},'\nCalculating a monotonic rational spline (linear or quadratic) or its inverse,\nplus the log(abs(detJ)) required for normalizing flows.\nNOTE: I omit the docstring with parameter descriptions for this method since it\nis not considered "public" yet!\n\n')))}f.isMDXComponent=!0}}]);