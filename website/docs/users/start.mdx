---
id: start
title: Your First Flow
sidebar_label: Your First Flow
---

## The Task
Let's begin learning our first Normalizing Flow with a simple example! The target distribution that we desire to learn will be,
$$
\begin{aligned}
  Y' &\sim \mathcal{N}\left(\mu=\begin{bmatrix}
   5 \\
   5
\end{bmatrix}, \Sigma=\begin{bmatrix}
   0.5 & 0 \\
   0 & 0.5
\end{bmatrix} \right)
\end{aligned},
$$
that is, a linear transformation of an standard multivariate normal distribution. The base distribution is,
$$
\begin{aligned}
  X &\sim \mathcal{N}\left(\mu=\begin{bmatrix}
   0 \\
   0
\end{bmatrix}, \Sigma=\begin{bmatrix}
   1 & 0 \\
   0 & 1
\end{bmatrix} \right)
\end{aligned},
$$
that is, standard normal noise (which is typical for Normalizing Flows). The task is to learn some bijection $g_\theta$ so that
$$
\begin{aligned}
  Y &\triangleq g_\theta(X) \\
  &\sim Y'
\end{aligned}
$$
approximately holds. We will define our Normalizing Flow, $g_\theta$ by a single affine transformation,
$$
\begin{aligned}
  g_\theta(\mathbf{x}) &\triangleq \begin{bmatrix}
   \mu_1 \\
   \mu_2(x_1)
\end{bmatrix} + \begin{bmatrix}
   \sigma_1 \\
   \sigma_2(x_1)
\end{bmatrix}\otimes\begin{bmatrix}
   x_1 \\
   x_2
\end{bmatrix}.
\end{aligned}
$$
In this notation, $\mathbf{x}=(x_1,x_2)^T$, $\otimes$ denotes element-wise multiplication, and the parameters are the scalars $\mu_1,\sigma_1$ and the parameters of the neural networks $\mu_2(\cdot)$ and $\sigma_2(\cdot)$. (Think of the NNs as very simple shallow feedforward nets in this example.) This is an example of [Inverse Autoregressive Flow](/dev/bibliography#kingma2016improving).

There are several metrics we could use to train $Y$ to be close in distribution to $Y'$. First, let us denote the target distribution of $Y'$ by $p(\cdot)$ and the learnable distribution of the normalizing flow, $Y$, as $q_\theta(\cdot)$ (in the following sections, we will explain how to calculate $q_\theta$ from $g_\theta$). Let's use the forward [KL-divergence](https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence),
$$
\begin{aligned}
\text{KL}\{p\ ||\ q_\theta\} &\triangleq \mathbb{E}_{p(\cdot)}\left[\log\frac{p(Y')}{q_\theta(Y')}\right] \\
&= -\mathbb{E}_{p(\cdot)}\left[\log q_\theta(Y')\right] + C,
\end{aligned}
$$
where C is a constant that does not depend on $\theta$. In practice, we draw a finite sample, $\{y_1,\ldots,y_M\}$, from $p$ and optimize a [Monte Carlo estimate](https://en.wikipedia.org/wiki/Monte_Carlo_integration) of the KL-divergence with stochastic gradient descent so that the loss is,
$$
\begin{aligned}
   \mathcal{L}(\theta) &= -\frac{1}{M}\sum^M_{m=1}\log(q_\theta(y_m))
\end{aligned}
$$

*So, to summarize, the task at hand is to learn how to transform standard bivariate normal noise into another bivariate normal distribution using an affine transformation, and we will do so by matching distributions with the KL-divergence metric.*

## Implementation
First, we import the relevant libraries:
```python
import torch
import torch.distributions as dist
import flowtorch
import flowtorch.bijectors as bijectors
```
The base and target distributions are defined using standard PyTorch:
```python
base_dist = dist.Normal(torch.zeros(2), torch.ones(2))
target_dist = dist.Normal(torch.zeros(2)+5, torch.ones(2)*0.5)
```
We can visualize samples from the base and target:
<p align="center">
<img src="/img/bivariate-normal-frame-0.svg" />
</p>

A Normalizing Flow is created in two steps. First, we create a "plan" for the flow as a `flowtorch.Bijector` object,
```python
# Lazily instantiated flow
flow = bijectors.AffineAutoregressive()
```
This plan is then made concrete by calling it with the base distribution,
```python
# Instantiate transformed distribution and parameters
new_dist, params = flow(base_dist)
```
At this point, we have an object, `new_dist`, for the distribution, $q_\theta(\cdot)$, that follows the standard PyTorch interface. Therefore, it can be trained with the following code, which will be familiar for readers who have used `torch.distributions` before:
```python
# Training loop
opt = torch.optim.Adam(params.parameters(), lr=5e-2)
for idx in range(501):
    opt.zero_grad()
    # Minimize KL(p || q)
    y = target_dist.sample((1000,))
    loss = -new_dist.log_prob(y).mean()
    if idx % 100 == 0:
        print('epoch', idx, 'loss', loss)
        
    loss.backward()
    opt.step()
```
Note how we obtain the learnable parameters of the normalizing flow from the `params` object, which is a `torch.nn.Module`. Visualizing samples after learning, we see that we have been successful in matching the target distribution:
<p align="center">
<img src="/img/bivariate-normal-frame-5.svg" />
</p>
Congratulations on training your first flow!

## Discussion

This simple example illustrates a few important points of FlowTorch's design:

Firstly, `Bijector` objects are agnostic to their shape. A `Bijector` object specifies *how the shape is changed* by the forward and inverse operations, and then calculates the exact shapes when it obtains knowledge of the base distribution, when `new_dist, params = flow(base_dist)` is run. Any neural networks or other parametrized functions, which also require this shape information, are not instantiated until the same moment. In this sense, a `Bijector` can be thought of as a lazy plan for creating a normalizing flow. The advantage of doing things this way is that the shape information can be "type checked" and does not need to be specified in multiple locations (ensuring these quantities are consistent).

Secondly, all objects are designed to have sensible defaults. We do not need to define the conditioning network for `bijectors.AffineAutoregressive`, it will use a [MADE network](/dev/bibliography#germain2015made) with sensible hyperparameters and defer initialization until it later receives shape information. Thirdly, there is compatibility, in as far as is possible, with standard PyTorch interfaces such as `torch.distributions` and `torch.distributions.transform`.